#include <stdio.h>
#include "ast.h"     // Include AST definitions
#include "symtab.h"  // Include Symbol Table definitions
#include "codegen.h" // Include Code Generator definitions

// --- External Declarations ---
// Function generated by Bison from parser.y
extern int yyparse(void);
// Function generated by Flex from lexer.l (optional, for setting input)
extern FILE *yyin;
// Global variable defined in parser.y to hold the root of the AST
extern Node *astRoot;
// Line number tracker from lexer.l (optional, useful for errors)
extern int yylineno;
// symtab_init/destroy defined in symtab.c

int main(int argc, char **argv) {
    FILE *inputFile = stdin;
    const char* out_filename = "output.c"; // Default output filename
    const char* in_filename = "stdin";

    // Basic argument handling
    if (argc > 1) {
        in_filename = argv[1];
        inputFile = fopen(in_filename, "r");
        if (!inputFile) {
            perror(in_filename);
            return 1;
        }
        yyin = inputFile; 
        if (argc > 2) { // Optional output file argument
            out_filename = argv[2];
        }
    } else {
        printf("Reading from standard input. Press Ctrl+D (Unix/Mac) or Ctrl+Z (Windows) to end.\n");
    }

    symtab_init(); // Initialize the symbol table

    printf("Parsing input from %s...\n", in_filename);
    int parse_result = yyparse(); // Start the parsing process

    if (inputFile != stdin) {
        fclose(inputFile);
    }

    if (parse_result == 0) { // 0 indicates successful parsing
        printf("Parsing successful!\n");
        symtab_print(); // Print symbol table content
        if (astRoot) {
            printf("--- Abstract Syntax Tree ---\n");
            // Print the list of statements if astRoot is the head
            Node* currentStatement = astRoot;
            while (currentStatement) {
                printAST(currentStatement, 0); 
                if (currentStatement->next) {
                     printf("  (Next Statement...)\n"); // Separator
                }
                currentStatement = currentStatement->next;
            }
            printf("--------------------------\n");
            
            // --- Code Generation ---
            FILE* outfile = fopen(out_filename, "w");
            if (!outfile) {
                 perror(out_filename);
                 freeAST(astRoot); // Still need to free AST
                 symtab_destroy();
                 return 1;
            }
            printf("Generating C code to %s...\n", out_filename);
            generateCode(astRoot, outfile);
            fclose(outfile);
            // -----------------------

            freeAST(astRoot); // Free the entire AST (should handle lists if freeAST is updated)
            astRoot = NULL;
        } else {
            printf("Parsing successful, but no AST generated (empty input?).\n");
        }
        symtab_destroy(); // Clean up symbol table memory
        return 0; // Success exit code
    } else { // Non-zero indicates a parsing error
        printf("Parsing failed.\n");
        // Cleanup partially built AST? Might be complex.
        // Cleanup symbol table
        symtab_destroy();
        return 1; // Failure exit code
    }
} 